import java.io.*;
/*
 * 스포일러 방지를 위해 맨 밑에 주석으로 풀이가 있습니다.
 * */

public class Main {
    static int N; // 색상 종류
    static int[] color = new int[6]; // 색상별 개수 (1~5 사용)
    static Long[][][][][][][] dp;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());

        for (int i = 1; i <= N; i++) {
            color[i] = Integer.parseInt(br.readLine());
        }

        // DP 테이블 초기화
        dp = new Long[11][11][11][11][11][6][6];

        // dfs 호출 (초기 상태: 모든 색상 남아있고, 이전 색상 없음)
        System.out.println(dfs(color[1], color[2], color[3], color[4], color[5], 0, 0));
    }

    static long dfs(int a, int b, int c, int d, int e, int prev1, int prev2) {
        if (a + b + c + d + e == 0) return 1;

        if (dp[a][b][c][d][e][prev1][prev2] != null)
            return dp[a][b][c][d][e][prev1][prev2];

        long res = 0;

        // 전과 전전에 선택한 색상과 다르며 && 아직 구슬이 남아있다면 dfs 진행
        for (int color = 1; color <= N; color++) {
            int[] left = {0, a, b, c, d, e};
            if (left[color] > 0 && (prev1 != color && prev2 != color)) {
                left[color]--;
                res += dfs(left[1], left[2], left[3], left[4], left[5], prev2, color);
            }
        }

        return dp[a][b][c][d][e][prev1][prev2] = res;
    }
}
/*
 * 1301 비즈 공예
 *
 * 다이나믹 프로그래밍 문제
 * @ !!! 해당 문제는 풀이를 참고했습니다. !!!
 *
 * ==================== 아래는 문제 해결을 위해 했던 시도 ========================
 *
 * 결론적으로, 구현에 실패했습니다.
 *
 * 해답을 보기 전, 저는 문제를 이렇게 풀이했었습니다.
 * 1. 입력 받는 N개의 숫자를 내림차 순으로 정렬한다.
 * 2. 구슬 숫자가 많은 순으로 먼저 가능한 배치(전에 배치에서 2칸 뒤에 배치)를 만들어간다.
 * 3. 모든 가능한 경우의 수만을 고려해서 마지막에 다다르면 결국 둘 수 있는 경우의 수는 항상 같다.
 * 4. 그렇다면 그 마지막 경우의 수를 기억하고(dp[N]), 그 전의 경우의 수마다 더해준다. (DP[N-1] += DP[N])
 * 5. 이를 반복하면 결국 가능한 경우의 수를 만날 때 마다 DP[N-1] += DP[N]은 반복한 결과가 같아지므로 연산을 절감할 수 있다.
 *
 * 제가 문제를 볼 때, 이것도 피보나치와 비슷하게 보였습니다.
 * 즉, 마지막에 다다르면 결국 둘 수 있는 경우의 수는 정해져있다고 판단한 것입니다.
 *
 * 다만, 이 형태로 풀이를 진행하려고 하자, 문제가 구현이 매우 복잡해지고 꼬이게 된다는 점이었습니다.
 * DP를 재귀적으로 구현하려고 했는데, 가능한 경우의 수를 찾는 것도 재귀적인 백트래킹이 필요하다고 느꼈습니다.
 * 그러면 재귀를 두번 하게 되고, 이는 간단히 생각해봐도 스택 오버플로우를 피할 수 없다고 판단했습니다.
 * 그래서 "경우의 수 찾기"와 "DP" 둘 중 하나를 반복문으로 만들려고 시도했는데.... 실패했습니다.
 *
 * 그래서 다른 사람 풀이를 확인하자, DP 배열에 상태를 저장하는 방식으로 해결했다는 점을 알았습니다.
 *
 * ============== 아래는 다른 사람 풀이를 보고 힌트를 얻은 후 풀이 =================
 *
 * 해결의 핵심은 dp 배열로 상태를 모두 저장하는 것 입니다.
 * dp[남은 구슬 갯수 최대 10개][10개][10개][10개][10개][전전에 고른 색상 5종][바로 전에 고른 색상 5종]
 *
 * 결국 백트래킹으로 경우의 수를 1번은 돌아봐야하는 점은 있지만, 끝에 다다르면 결국 나오게 되는 경우의 수는 같아집니다.
 * 즉, 1번이라도 결과를 낸 경우가 존재한다면 굳이 또 연산을 수행할 필요가 없다는 것을 알 수 있습니다.
 *
 * 그렇다면, dp[][][][][][][]의 배열을 만들어서, 각 경우를 기억하게 해줍니다.
 * Long dp[11][11][11][11][11][6][6]를 선언해서 처음엔 null로 만든 후,
 * 한번이라도 들리면 dp[a][b]...[prev2] = 0으로 초기값을 주는겁니다.
 *
 * 이후, 전과 전전에 선택한 색상과 다르며 && 아직 구슬이 남아있다면 모든 구슬을 소진할 때까지 백트래킹을 진행해줍니다.
 * 이를 반복하게 만들면 문제를 해결할 수 있습니다.
 *
 *
 *
 *
 * */