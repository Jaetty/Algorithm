/*
 * 스포일러 방지를 위해 맨 밑에 주석으로 풀이가 있습니다.
 * */

class Solution {

    public int solution(int m, int n, int[][] puddles) {

        int[][] map = new int[n+1][m+1];

        if(puddles != null){
            for(int i=0; i<puddles.length; i++){
                map[puddles[i][1]][puddles[i][0]] = -1;
            }
        }

        map[1][1] = 1;

        for(int i=1; i<=n; i++){

            for(int j=1; j<=m; j++){

                if(map[i][j]==-1) continue;
                map[i][j] += ((map[i-1][j] < 0 ? 0 : map[i-1][j]) + (map[i][j-1] < 0 ? 0 : map[i][j-1])) % 1_000_000_007;

            }

        }

        return map[n][m];
    }


}

/*
 * 다이나믹 프로그래밍 문제
 *
 * 해당 문제의 경우 점화식이 문제에서 그대로 주어져서 물웅덩이에만 주의해서 구현만 해주면 되는 문제입니다.
 * 점화식의 경우 어떤 해당 위치 map[i][j]에서 r행의 바로 위, c행의 바로 전에 저장된 값을 더해주면 됩니다. (map[i][j] += map[i-1][j] + map[i][j-1] % 100000007)
 * 이때 주의할 점은 물웅덩이가 있을 때는 그냥 넘어가야한다는 점 입니다.
 * 그래서 먼저 물웅덩이를 전체 배열에서 다르게 표시해줍니다. (저는 절대 나올 리 없는 음수 값을 넣어줬습니다.)
 * 그래서 만약 다르게 표시한 값을 만나게 되면 그 부분은 점화식을 수행하지 않기만 하면 됩니다.
 * 마지막으로 이중 for문으로 값이 순서대로 골고루 갱신되도록 구현해주면 문제를 풀이할 수 있습니다.
 *
 * */